"function" == typeof SuppressedError && SuppressedError;
const e = "string";
const t = "boolean";
const n = "number";
const o = "symbol";
const s = "bigint";
const r = "object";
var a = [
  r,
  (e) => {
    const t = "string" == typeof e ? JSON.parse(e) : e,
      n = {};
    return (
      Object.entries(t).forEach(([e, t]) => {
        const { $type: o, $value: s } = t;
        n[e] = y[o].from(s);
      }),
      n
    );
  },
  (e) => {
    const t = {};
    return (
      Object.entries(e).forEach(([e, n]) => {
        t[e] = m(n);
      }),
      { $type: r, $value: t }
    );
  },
];
const c = "null";
const i = "function";
const l = "array";
var p = [
  l,
  (e) => {
    const t = "string" == typeof e ? JSON.parse(e) : e,
      n = [];
    return (
      t.forEach((e, t) => {
        const { $type: o, $value: s } = e;
        n[t] = y[o].from(s);
      }),
      n
    );
  },
  (e) => {
    const t = [];
    return (
      e.forEach((e, n) => {
        t[n] = m(e);
      }),
      { $type: l, $value: t }
    );
  },
];
var u = [
  "set",
  (e) => {
    const t = "string" == typeof e ? JSON.parse(e) : e,
      n = new Set();
    return (
      t.forEach((e) => {
        const { $type: t, $value: o } = e,
          s = y[t].from(o);
        n.add(s);
      }),
      n
    );
  },
  (e) => ({ $type: "set", $value: Array.from(e).map((e) => m(e)) }),
];
var g = [
  "map",
  (e) => {
    const t = "string" == typeof e ? JSON.parse(e) : e,
      n = new Map();
    return (
      t.forEach(([e, t]) => {
        const { $type: o, $value: s } = e;
        e = y[o].from(s);
        const { $type: r, $value: a } = t;
        (t = y[r].from(a)), n.set(e, t);
      }),
      n
    );
  },
  (e) => {
    const t = e.entries(),
      n = [];
    for (const [e, o] of t) {
      const t = m(e),
        s = m(o);
      n.push([t, s]);
    }
    return { $type: "map", $value: n };
  },
];
const h = "date";
const f = "regexp";
const d = "undefined";
const y = [
    [e, (e) => e, (t) => ({ $type: e, $value: t })],
    [t, (e) => "true" === e, (e) => ({ $type: t, $value: e })],
    [n, (e) => +e, (e) => ({ $type: n, $value: "" + e })],
    [o, (e) => Symbol.for(e), (e) => ({ $type: o, $value: e.description })],
    [s, (e) => BigInt(e), (e) => ({ $type: s, $value: "" + e })],
    a,
    [c, (e) => null, (e) => ({ $type: c, $value: "" + e })],
    [
      i,
      (e) => {
        const t = e.startsWith("function") ? e : "function " + e;
        return new Function("...rest", "return (" + t + ")(...rest)");
      },
      (e) => ({ $type: i, $value: e.toString() }),
    ],
    p,
    u,
    g,
    [h, (e) => new Date(+e), (e) => ({ $type: h, $value: "" + e.getTime() })],
    [f, (e) => new RegExp(e), (e) => ({ $type: f, $value: e.source })],
    [d, () => {}, () => ({ $type: d, $value: "undefined" })],
  ].reduce((e, t) => {
    const [n, o, s] = t;
    return Object.assign(e, { [n]: { from: o, to: s } }), e;
  }, {}),
  $ = "BroadcastChannel" in window,
  v = "localStorage" in window,
  w = (e) => {
    const t = JSON.parse(e),
      { $payload: n } = t,
      o = (function (e, t) {
        var n = {};
        for (var o in e)
          Object.prototype.hasOwnProperty.call(e, o) &&
            t.indexOf(o) < 0 &&
            (n[o] = e[o]);
        if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
          var s = 0;
          for (o = Object.getOwnPropertySymbols(e); s < o.length; s++)
            t.indexOf(o[s]) < 0 &&
              Object.prototype.propertyIsEnumerable.call(e, o[s]) &&
              (n[o[s]] = e[o[s]]);
        }
        return n;
      })(t, ["$payload"]),
      s = Object.assign(Object.assign({}, o), { $payload: {} }),
      { $type: r, $value: a } = n;
    return (s.$payload = y[r].from(a)), s;
  },
  m = (e) => {
    const t =
      y[
        ((n = e),
        void 0 === n
          ? "undefined"
          : null === n
          ? "null"
          : n.constructor.name.toLowerCase())
      ];
    var n;
    return t && (e = t.to(e)), e;
  },
  E = (e, t) => {
    const n = m(e);
    return {
      $timezone: Date.now(),
      $origin: location.href,
      $payload: n,
      $target: "string" == typeof t ? t : null == t ? void 0 : t.source,
    };
  },
  S = (e, t) => !t || new RegExp(t).test(e),
  M = {},
  b = (e, t) => {
    let { chan: n } = e;
    const o = M[n],
      s = o || new BroadcastChannel(n);
    s.addEventListener("message", (e) => {
      try {
        const n = w(e.data);
        if (n.$origin === location.href) return;
        if (!S(location.href, n.$target)) return;
        "function" == typeof t && t(n);
      } catch (e) {
        console.error(e);
      }
    }),
      !o && (M[n] = s);
  },
  O = (e, t, n) => {
    const { chan: o } = e,
      s = E(t, n),
      r = M[o],
      a = r || new BroadcastChannel(o);
    a.postMessage(JSON.stringify(s)), !r && (M[o] = a);
  },
  j = (e, t) => {
    const { chan: n } = e,
      o = M[n],
      s = o || new BroadcastChannel(n);
    s.addEventListener("messageerror", (e) => {
      "function" == typeof t && t(e);
    }),
      !o && (M[n] = s);
  },
  x = (e) => {
    const { chan: t } = e,
      n = M[t];
    if (!n) throw new Error(`the channel named ${t} isn't exist`);
    n.close();
  },
  B = {},
  C = (e, t) => {
    const { chan: n } = e;
    window.addEventListener("storage", (e) => {
      if (e.key === n)
        try {
          const n = w(e.newValue);
          if (!S(location.href, n.$target)) return;
          "function" == typeof t && t(n);
        } catch (e) {
          console.error(e);
        }
    });
  },
  I = (e, t, n) => {
    const { chan: o } = e,
      s = E(t, n),
      r = JSON.stringify(s);
    try {
      window.localStorage.setItem(o, r);
    } catch (e) {
      (B[o] || [] || []).forEach((t) => {
        t(e);
      });
    }
  },
  J = (e, t) => {
    const { chan: n } = e;
    B[n] instanceof Array ? B[n].push(t) : (B[n] = [t]);
  },
  N = (e) => {
    const { chan: t } = e,
      n = localStorage.setItem;
    localStorage.setItem = (e, o) => {
      e !== t && n(e, o);
    };
    const o = localStorage.getItem;
    localStorage.getItem = (e) => {
      if (e !== t) return o(e);
    };
  };
class L {}
class P extends L {
  constructor(e) {
    super(), (this.options = e);
  }
  onMessage(e) {
    C(this.options, e);
  }
  onSendMessageError(e) {
    J(this.options, e);
  }
  sendMessage(e, t) {
    I(this.options, e, t);
  }
  close() {
    N(this.options);
  }
}
class A extends L {
  constructor(e) {
    super(), (this.options = e);
  }
  onMessage(e) {
    b(this.options, e);
  }
  sendMessage(e, t) {
    O(this.options, e, t);
  }
  onSendMessageError(e) {
    j(this.options, e);
  }
  close() {
    x(this.options);
  }
}
const D = $ || v;
class R {
  constructor(e) {
    if (((this.options = { engine: "BroadcastChannel" }), !D))
      throw new Error("The library doesn't support your browser.");
    (e.chan = btoa(e.chan)), Object.assign(this.options, e), this.initEngine();
  }
  initEngine() {
    const { engine: e } = this.options,
      t = { BroadcastChannel: A, LocalStorage: P };
    this.instance = new t[e](this.options);
  }
  onMessage(e) {
    this.instance.onMessage(e);
  }
  sendMessage(e, t) {
    this.instance.sendMessage(e, t);
  }
  onMessageError(e) {
    this.instance.onSendMessageError(e);
  }
  close() {
    this.instance.close();
  }
}
const T = $ || v,
  k = (e) => {
    if (!T) throw new Error("the lib isn't support your browser.");
    e = Object.assign({ engine: "BroadcastChannel" }, e);
    const t = [
      {
        engine: "BroadcastChannel",
        support: $,
        onMessage: b,
        sendMessage: O,
        onSendMessageError: j,
        close: x,
      },
      {
        engine: "LocalStorage",
        support: v,
        onMessage: C,
        sendMessage: I,
        onSendMessageError: J,
        close: N,
      },
    ].find((t) => t.engine === e.engine && t.support);
    return {
      onMessage: (n) => t.onMessage(e, n),
      sendMessage: (n, o) => t.sendMessage(e, n, o),
      onMessageError: (n) => t.onSendMessageError(e, n),
      close: () => t.close(e),
    };
  };
export { R as DataSynchronizer, k as useDataSynchronizer };
